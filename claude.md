# FlowState Development Guide

## Project Overview

FlowState is a **realtime dynamic NFT social protocol** built on Monad blockchain. It creates evolving NFT identities that update in real-time based on on-chain social interactions.

### Core Value Proposition
- 100% on-chain social identity
- Real-time NFT state updates (minute-level)
- High-frequency, low-cost social interactions
- Leverages Monad's parallel execution capabilities

---

## Tech Stack

### Development Framework
- **Scaffold-ETH 2**: Primary development framework
  - Integrated Hardhat + Next.js environment
  - Pre-configured wagmi v2 + viem
  - Built-in contract hot reload
  - Debug contracts UI out of the box
  - Quick deployment scripts

### Smart Contracts
- **Language**: Solidity ^0.8.20
- **Framework**: Hardhat (via Scaffold-ETH) + Foundry (for testing)
- **Network**: Monad Testnet/Mainnet
- **Standards**: ERC-721 (with custom extensions)

### Frontend
- **Framework**: Next.js 14+ (App Router, via Scaffold-ETH)
- **Language**: TypeScript
- **Styling**: Tailwind CSS + DaisyUI (Scaffold-ETH default)
- **Web3**: viem + wagmi v2 (pre-configured)
- **State**: React Query / SWR for polling
- **Components**: Scaffold-ETH hooks & components

### Development Tools
- **Testing**: Foundry forge test + Hardhat test
- **Deployment**: Scaffold-ETH deploy scripts
- **Local Chain**: Hardhat node (or Anvil)
- **Formatting**: prettier, solhint

---

## Project Structure

```
flowstate/                          # Scaffold-ETH 2 based
├── packages/
│   ├── hardhat/
│   │   ├── contracts/
│   │   │   ├── FlowNFT.sol          # Main NFT contract
│   │   │   ├── ActivityTracker.sol   # Behavior tracking
│   │   │   ├── TipModule.sol         # Micro-tipping logic
│   │   │   └── libraries/
│   │   │       ├── FlowState.sol     # State calculation
│   │   │       └── SVGRenderer.sol   # On-chain SVG (optional)
│   │   ├── deploy/
│   │   │   └── 00_deploy_flowstate.ts
│   │   └── test/
│   │       └── FlowNFT.test.ts
│   └── nextjs/
│       ├── app/
│       │   ├── page.tsx              # Main page
│       │   ├── mint/
│       │   │   └── page.tsx          # Mint page
│       │   └── profile/
│       │       └── [address]/
│       │           └── page.tsx      # Profile page
│       ├── components/
│       │   ├── flowstate/
│       │   │   ├── FlowNFTCard.tsx   # NFT display
│       │   │   ├── TipButton.tsx     # Tip interaction
│       │   │   ├── LikeButton.tsx    # Like interaction
│       │   │   └── StateIndicator.tsx # Real-time state
│       │   └── scaffold-eth/         # SE-2 built-in components
│       ├── hooks/
│       │   └── flowstate/
│       │       ├── useFlowNFT.ts
│       │       ├── useFlowState.ts
│       │       └── useActivityTracker.ts
│       ├── contracts/
│       │   └── deployedContracts.ts  # Auto-generated by SE-2
│       └── scaffold.config.ts        # Chain config (add Monad)
├── foundry/                          # Optional: Foundry for advanced testing
│   ├── test/
│   └── foundry.toml
└── README.md
```

### Scaffold-ETH 2 Setup

```bash
# Clone and setup
npx create-eth@latest flowstate
cd flowstate

# Add Monad network config in scaffold.config.ts
# Start local development
yarn chain    # Start local Hardhat node
yarn deploy   # Deploy contracts
yarn start    # Start Next.js frontend
```

---

## Smart Contract Specifications

### 1. FlowNFT.sol

```solidity
// Core requirements:
// - One NFT per address (soulbound or state-reset on transfer)
// - Dynamic tokenURI based on FlowState
// - Integration with ActivityTracker

interface IFlowNFT {
    function mint() external;
    function tokenURI(uint256 tokenId) external view returns (string memory);
    function getFlowState(address user) external view returns (FlowState memory);
    function tokenOfOwner(address owner) external view returns (uint256);
}

struct FlowState {
    uint256 currentEpoch;
    uint256 likesReceived;
    uint256 likesSent;
    uint256 tipsReceived;
    uint256 tipsSent;
    uint256 totalInteractions;
}
```

**Key Implementation Notes:**
- Use `block.timestamp / 60` for epoch calculation
- Store only current and previous epoch data
- Implement `_beforeTokenTransfer` to handle soulbound logic

### 2. ActivityTracker.sol

```solidity
interface IActivityTracker {
    function like(address target) external;
    function recordActivity(address user, ActivityType actType) external;
    function getEpochStats(address user, uint256 epoch) external view returns (EpochStats memory);
}

enum ActivityType { LIKE, TIP, COMMENT }

struct EpochStats {
    uint64 likesReceived;
    uint64 likesSent;
    uint64 tipsReceived;
    uint64 tipsSent;
}
```

**Key Implementation Notes:**
- Use packed structs to minimize storage
- Implement epoch rollover without explicit cleanup
- Events for all activities (for UI updates)

### 3. TipModule.sol

```solidity
interface ITipModule {
    function tip(address recipient) external payable;
    function withdraw() external;
}
```

**Key Implementation Notes:**
- Minimum tip: 0.0001 ETH (100000000000000 wei)
- Use ReentrancyGuard
- Update both sender and recipient states atomically

---

## Epoch & State Calculation

### Rolling Window Logic

```solidity
function getCurrentEpoch() public view returns (uint256) {
    return block.timestamp / 60; // 1-minute epochs
}

function getActiveState(address user) public view returns (uint256 level) {
    uint256 currentEpoch = getCurrentEpoch();
    uint256 current = epochStats[user][currentEpoch].totalInteractions;
    uint256 previous = epochStats[user][currentEpoch - 1].totalInteractions;
    uint256 total = current + previous;
    
    if (total >= 20) return 2; // Burning
    if (total >= 5) return 1;  // Active
    return 0;                   // Idle
}
```

### State Mapping

| Level | Name | Total Interactions (2 epochs) | Visual |
|-------|------|------------------------------|--------|
| 0 | Idle | 0-4 | Gray/Dim |
| 1 | Active | 5-19 | Blue/Glow |
| 2 | Burning | 20+ | Orange/Fire |

---

## Frontend Implementation

### Real-time Updates Strategy (Scaffold-ETH 2)

```typescript
// Leverage SE-2's useScaffoldContractRead with watch: true
import { useScaffoldContractRead } from "~~/hooks/scaffold-eth";

const { data: flowState } = useScaffoldContractRead({
  contractName: "FlowNFT",
  functionName: "getFlowState",
  args: [address],
  watch: true,           // Auto-poll on new blocks
  pollingInterval: 3000, // 3 second fallback
});

// Optimistic updates after user actions
const { writeAsync: tip, isLoading } = useScaffoldContractWrite({
  contractName: "TipModule",
  functionName: "tip",
  args: [targetAddress],
  value: parseEther("0.001"),
  onBlockConfirmation: () => {
    notification.success("Tip sent!");
  },
});
```

### Event Subscription (SE-2)

```typescript
import { useScaffoldEventHistory } from "~~/hooks/scaffold-eth";

// Watch for state changes in real-time
const { data: stateChanges } = useScaffoldEventHistory({
  contractName: "FlowNFT",
  eventName: "StateChanged",
  fromBlock: BigInt(0),
  watch: true,
  filters: { user: address },
});
```

### Component Requirements

**FlowNFTCard**
- Display current state visually (Idle/Active/Burning)
- Show interaction counts
- Animate state transitions
- Use SE-2's `Address` component for display
- Responsive design with DaisyUI

**TipButton**
- Quick tip presets (0.001, 0.01, 0.1 ETH)
- Custom amount input
- Use SE-2's loading states
- Disable during pending tx
- Toast notifications via SE-2

**StateIndicator**
- Real-time epoch countdown
- State level indicator with animations
- Interaction counter
- Use SE-2's `useAnimationConfig`

---

## API / Contract Interaction (Scaffold-ETH 2)

### Key Read Functions

```typescript
import { useScaffoldContractRead } from "~~/hooks/scaffold-eth";

// Get user's NFT token ID
const { data: tokenId } = useScaffoldContractRead({
  contractName: "FlowNFT",
  functionName: "tokenOfOwner",
  args: [address],
});

// Get current flow state (with auto-refresh)
const { data: state } = useScaffoldContractRead({
  contractName: "FlowNFT",
  functionName: "getFlowState",
  args: [address],
  watch: true,
});

// Get dynamic metadata
const { data: uri } = useScaffoldContractRead({
  contractName: "FlowNFT",
  functionName: "tokenURI",
  args: [tokenId],
  watch: true,
});
```

### Key Write Functions

```typescript
import { useScaffoldContractWrite } from "~~/hooks/scaffold-eth";
import { parseEther } from "viem";

// Mint NFT (one-time)
const { writeAsync: mint, isLoading: isMinting } = useScaffoldContractWrite({
  contractName: "FlowNFT",
  functionName: "mint",
});

// Like a user
const { writeAsync: like } = useScaffoldContractWrite({
  contractName: "ActivityTracker",
  functionName: "like",
  args: [targetAddress],
});

// Tip a user
const { writeAsync: tip } = useScaffoldContractWrite({
  contractName: "TipModule",
  functionName: "tip",
  args: [targetAddress],
  value: parseEther("0.001"),
});
```

### Direct Contract Access (Advanced)

```typescript
import { useDeployedContractInfo } from "~~/hooks/scaffold-eth";
import { usePublicClient, useWalletClient } from "wagmi";

// Get contract instance for complex operations
const { data: flowNFTInfo } = useDeployedContractInfo("FlowNFT");
const publicClient = usePublicClient();

// Direct read
const state = await publicClient.readContract({
  address: flowNFTInfo.address,
  abi: flowNFTInfo.abi,
  functionName: "getFlowState",
  args: [address],
});
```

---

## Events (for UI subscriptions)

```solidity
event NFTMinted(address indexed owner, uint256 indexed tokenId);
event Liked(address indexed from, address indexed to, uint256 epoch);
event Tipped(address indexed from, address indexed to, uint256 amount, uint256 epoch);
event StateChanged(address indexed user, uint256 oldLevel, uint256 newLevel);
```

---

## Testing Requirements

### Unit Tests (Hardhat - Scaffold-ETH 2)

```typescript
// packages/hardhat/test/FlowNFT.test.ts
import { expect } from "chai";
import { ethers } from "hardhat";

describe("FlowNFT", function () {
  it("Should mint only once per address", async function () {
    const [owner] = await ethers.getSigners();
    const FlowNFT = await ethers.getContractFactory("FlowNFT");
    const flowNFT = await FlowNFT.deploy();
    
    await flowNFT.mint();
    await expect(flowNFT.mint()).to.be.revertedWith("Already minted");
  });

  it("Should update state on like", async function () {
    // ... test implementation
  });
});

// Run: yarn hardhat:test
```

### Unit Tests (Foundry - Optional Advanced)

```solidity
// foundry/test/FlowNFT.t.sol
// Test cases required:
- test_MintOnlyOnce()
- test_LikeUpdatesState()
- test_TipMinimumAmount()
- test_TipUpdatesBothParties()
- test_EpochRollover()
- test_StateCalculation()
- test_TokenURIChangesWithState()
- test_ReentrancyProtection()

// Run: cd foundry && forge test
```

### Integration Tests

- Simulate 100+ interactions in single block
- Verify parallel execution doesn't cause conflicts
- Test epoch boundary conditions
- Use SE-2's local Hardhat network for fast iteration

---

## Gas Optimization Guidelines

1. **Pack structs** - Use uint64/uint32 where possible
2. **Minimize storage writes** - Batch updates when possible
3. **Use events for history** - Don't store historical data on-chain
4. **Optimize tokenURI** - Keep metadata minimal for on-chain generation

---

## Deployment Checklist

### Pre-deployment
- [ ] All tests passing (`yarn hardhat:test` + `forge test`)
- [ ] Gas estimates acceptable
- [ ] Monad network configured in `scaffold.config.ts`
- [ ] Environment variables set (`.env`)

### Scaffold-ETH 2 Deploy Flow

```bash
# 1. Configure deployment script
# packages/hardhat/deploy/00_deploy_flowstate.ts

# 2. Deploy to Monad testnet
yarn deploy --network monadTestnet

# 3. Verify contracts (if explorer supports)
yarn verify --network monadTestnet

# 4. Start frontend
yarn start
```

### Deploy Script Example

```typescript
// packages/hardhat/deploy/00_deploy_flowstate.ts
import { HardhatRuntimeEnvironment } from "hardhat/types";
import { DeployFunction } from "hardhat-deploy/types";

const deployFlowState: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const { deployer } = await hre.getNamedAccounts();
  const { deploy } = hre.deployments;

  // 1. Deploy FlowNFT
  const flowNFT = await deploy("FlowNFT", {
    from: deployer,
    args: [],
    log: true,
    autoMine: true,
  });

  // 2. Deploy ActivityTracker
  const activityTracker = await deploy("ActivityTracker", {
    from: deployer,
    args: [flowNFT.address],
    log: true,
  });

  // 3. Deploy TipModule
  const tipModule = await deploy("TipModule", {
    from: deployer,
    args: [flowNFT.address, activityTracker.address],
    log: true,
  });

  // 4. Configure FlowNFT
  const flowNFTContract = await hre.ethers.getContract("FlowNFT", deployer);
  await flowNFTContract.setActivityTracker(activityTracker.address);
  await flowNFTContract.setTipModule(tipModule.address);
};

export default deployFlowState;
deployFlowState.tags = ["FlowState"];
```

### Post-deployment
- [ ] Contracts auto-generated in `deployedContracts.ts`
- [ ] Debug UI accessible at `/debug`
- [ ] Test mint on testnet
- [ ] Test like/tip flows
- [ ] Verify metadata updates in real-time

---

## Demo Script (Hackathon)

### Using Scaffold-ETH 2 Debug UI

1. **Show Debug Page** (`/debug`) - Demonstrate auto-generated contract UI
2. **Mint** - Use debug UI to mint, show NFT in Idle state
3. **Like** - Send 5 likes via debug UI, watch state change to Active
4. **Tip** - Send tips rapidly, demonstrate high-frequency capability
5. **State Change** - Wait for epoch, show Burning state
6. **Multiple Users** - Show parallel interactions from different accounts
7. **Event Logs** - Show real-time event streaming in debug UI

### Demo Tips for SE-2
- Keep `/debug` page open alongside main UI
- Use Burner Wallet for quick demo transactions
- Show contract state viewer updating in real-time
- Highlight "this works out of the box with Scaffold-ETH 2"

---

## Key Monad Differentiators to Highlight

1. **Parallel Execution**: Multiple users can interact simultaneously without conflicts
2. **Low Gas**: Micro-tipping ($0.01) is economically viable
3. **Fast Finality**: Sub-second feedback for social interactions
4. **MonadDB**: Efficient state reads for real-time UI updates

---

## Common Pitfalls to Avoid

### Contract Development
1. ❌ Don't store full history on-chain (use events)
2. ❌ Don't use large strings in metadata
3. ❌ Don't forget reentrancy guard on tip function
4. ❌ Don't rely on block.timestamp for precise timing
5. ❌ Don't make tokenURI computationally expensive

### Scaffold-ETH 2 Specific
6. ❌ Don't forget to update `scaffold.config.ts` for Monad
7. ❌ Don't manually manage ABIs - let SE-2 auto-generate
8. ❌ Don't skip `yarn deploy` after contract changes
9. ✅ DO use `/debug` page for quick testing
10. ✅ DO leverage SE-2 hooks instead of raw wagmi for simplicity

---

## Resources

- [Scaffold-ETH 2 Documentation](https://docs.scaffoldeth.io)
- [Scaffold-ETH 2 GitHub](https://github.com/scaffold-eth/scaffold-eth-2)
- [Monad Documentation](https://docs.monad.xyz)
- [ERC-721 Standard](https://eips.ethereum.org/EIPS/eip-721)
- [Foundry Book](https://book.getfoundry.sh)
- [Wagmi Documentation](https://wagmi.sh)

---

## Scaffold-ETH 2 Specific Setup

### Add Monad Network

```typescript
// packages/nextjs/scaffold.config.ts
import { defineChain } from "viem";

const monadTestnet = defineChain({
  id: 10143,  // Monad testnet chain ID (verify latest)
  name: "Monad Testnet",
  network: "monad-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Monad",
    symbol: "MON",
  },
  rpcUrls: {
    default: { http: ["https://testnet-rpc.monad.xyz"] },
    public: { http: ["https://testnet-rpc.monad.xyz"] },
  },
  blockExplorers: {
    default: { name: "Monad Explorer", url: "https://testnet.monadexplorer.com" },
  },
});

const scaffoldConfig = {
  targetNetworks: [monadTestnet],
  // ... rest of config
};
```

### Leverage SE-2 Built-in Hooks

```typescript
// Use Scaffold-ETH 2 hooks for contract interaction
import { useScaffoldContractRead, useScaffoldContractWrite } from "~~/hooks/scaffold-eth";

// Read flow state
const { data: flowState } = useScaffoldContractRead({
  contractName: "FlowNFT",
  functionName: "getFlowState",
  args: [address],
  watch: true,  // Auto-refresh
});

// Write: Tip action
const { writeAsync: tip } = useScaffoldContractWrite({
  contractName: "TipModule",
  functionName: "tip",
  args: [targetAddress],
  value: parseEther("0.001"),
});
```

### SE-2 Debug UI Benefits

- Auto-generated contract interaction UI at `/debug`
- Real-time event logs
- Contract state viewer
- Perfect for hackathon demos
